\lheader{Нетривиальные типы данных в паскале}

\textbf{Вещественные типы.} Как известно, в паскале есть 4 "<настоящих"> вещественных типа: 
real, single, double и extended (про comp разговор будет ниже). Из них последние три "--- 
стандартные типы, они поддерживаются математическим сопроцессором, который, насколько я понимаю, 
давно встроен во все современные  процессоры. А первый (real) в Borland Pascal обрабатывался 
полностью программно, из процессорных функций используя, 
видимо, только работу с целыми числами; в современных версиях это как правило или single или 
double, в зависимости от настроек (а, возможно, при определенных настройках это может быть и старый странный тип).  

Как итог, в других языках программирования есть типы, полностью совпадающие 
по структуре с signle и double (float и long float в C/C++, насколько я понимаю), и могут быть 
типы, полностью совпадающие с extended (типа long long float в некоторых компиляторах C/C++). 
Это, правда, нам будет фактически не  
важно, оно лишь приводит к тому, что, передавая, например, число типа single напрямую как оно записано в 
памяти "--- четырьмя байтами "--- в другую программу, вы без проблем сможете работать с ним там, 
даже если другая программа написана на другом языке, а вот с real не все так просто, надо понимать, какой именно это тип , "--- но такая 
необходимость в олимпиадных задачах возникает очень редко.
Аналогично, \texttt{file of single} (см. ниже) можно читать программой, написанной на любом (ну... 
почти любом "--- ещё бывают проблемы с порядком байт) языке программирования, а с \texttt{file of 
real} все сложнее.

Но все равно даже сам факт того, что real это либо single, либо double, либо что-то еще, делает тип real некоторым "<искусственным 
включением"> в системы типов. Это неудивительно: насколько я понимаю, во времена создания паскаля 
далеко не все компьютеры оснащались сопроцессором (да и, возможно, не было общепринятых стандартов 
хранения вещественных чисел в памяти), и потому был изобретён новый тип, чтобы можно было работать 
с вещественными числами и без сопроцессора. В современных же условиях нет необходимости так 
хитрить, и потому тип real фактически не нужен, поэтому его и приравняли к single/double. Поэтому 
фактически \textbf{никогда} не следует использовать в своих программах этот тип, пользуйтесь лучше single, double или extended. 

Какой же из трёх оставшихся типов использовать? Конечно, все зависит от задачи. Операции с single 
выполняются довольно быстро (но тем не менее, конечно, много дольше, чем операции с целыми 
числами), но, как правило, точности single не хватает в олимпиадных задачах (хотя в неолимпиадных 
вполне может хватать). Double обычно 
обеспечивает достаточную точность, но работает дольше, чем single. Extended обеспечивает ещё 
б\'ольшую точность, но ценой несоразмерного увеличения времени обработки. (Ну и, конечно, типы 
расходуют разное число байт: single 4, double 8, extended 10.) Тем не менее я всегда 
использовал где можно extended, и только если начинались проблемы с памятью или временем, переходил 
на double или в крайнем случае single. ИМХО, как правило, в олимпиадных задачах, где требуется 
вещественная арифметика, обычно время и память не столь критичны, чтобы надо было от extended 
уходить к другим типам.

Кстати, не забываем, что при работе с вещественными числами нельзя писать \verb|if a=0| и т.п., а надо работать с \verb|eps|.

\textbf{Нетривиальные целочисленные типы.} Пожалуй, ограничусь просто перечислением.
\begin{ulist}
\item \texttt{integer}. Казалось бы, ничего особенного, но в FP он занимает 2 или 4 байта в 
зависимости от настроек, и хранит соответствующий диапазон чисел. Советую в FP всегда писать 
\verb|{$mode delphi}| (см. ниже), и не иметь проблем. Двухбайтный тип, 
аналогичный BP'шному integer, называется smallint (а есть ещё и однобайтный shortint, такой же, как 
и в BP). 
\item \texttt{cardinal}, он же \texttt{longword}\footnote{Тут, похоже, есть какая"=то очень тонкая 
разница, связанная с поведение на разных платформах и ОС, но я её не знаю}. Это беззнаковый 
32-битный тип (т.е. как word относится к integer, так cardinal относится к longint). 
Соответственно, позволяет хранить числа от 0 до $2^{32}-1\approx 4\,000\,000\,000$.
\item \texttt{int64}. Знаковый (т.е. может хранить отрицательные числа) 64-битный тип. 
Хранит числа от $\approx -2^{63}$ до $\approx 2^{63}$ (пишу 
$\approx$, т.к. там где"=то граница отличается на единицу от степени двойки, даже понятно, где). 
\item \texttt{comp}. Аналогично int64 знаковый 64-битный тип. Но, в отличие от int64, он, видимо, 
поддерживается \textit{не} самим процессором, а сопроцессором (могу и ошибаться!). Поэтому есть ряд 
особенностей: во"=первых, comp был доступен даже в BP, во"=вторых, 
компилятор считает его вещественным типом со всеми вытекающими отсюда последствиями. В т.ч. его 
нельзя напрямую присваивать переменным целого типа, надо делать \texttt{round} и т.п.; с ним не 
работает \texttt{mod} и \texttt{div}, зато работает \texttt{/}, которое "--- внимание! "--- 
округляет результат по правилу round: 5/3=2, если считать в comp; при выводе в файл или на экран 
надо писать \verb|:0:0|, иначе будет вывод в виде с плавающей точкой (\verb|2.36348e5| типа того); 
кроме того, при выводе могут произойти глюки: существует небольшое количество значений comp, 
которые даже с \verb|:0:0| выводятся с ошибкой в паре последних знаков (хотя в памяти хранится 
точное значение!), поэтому с ним надо быть всегда осторожным. Т.е. comp выполняет все вычисления в 
пределах 64-битных целых значений абсолютно точно (как и любой целочисленный тип в пределах своей 
области значений), но есть приколы, которые надо понимать. Поэтому не используйте comp, используйте 
int64!
\end{ulist}