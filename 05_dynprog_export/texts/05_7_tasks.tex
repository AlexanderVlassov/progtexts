\header{Дополнительные задачи}
\task|Найти число способов разложить данное число $N$ в сумму слагаемых: а) 
считая разложения, различающиеся порядком слагаемых, различными; б) считая разложения, 
различающиеся порядком слагаемых, одинаковыми; в) считая разложения, 
различающиеся порядком слагаемых, одинаковыми и требуя, чтобы все слагаемые 
в каждом разложении были различны; г) и т.п.
||||Может быть, тут тоже все проще понять, если подумать, как бы вы писали перебор (а в переборе была такая задача :) ). Например, вариант а: разложения, различающиеся порядком слагаемых, считаются различными. Как бы мы писали перебор: мы бы просто перебирали, какое будет очередное слагаемое, и для каждого варианта запускались бы рекурсивно. Можно это сделать функцией, которая будет возвращать число способов разбиения на слагаемые того, что осталось. Если попытаться теперь это превратить в рекурсию с запоминанием результата, то какие вызовы функций нам надо объединить, т.е. какие вызовы будут возвращать один и тот же результат? Ну ясно, те, которые просто считают число способов разбиения для одного и того же числа (т.е. единственный важный тут параметр "--- это сколько нам осталось разбить). Т.е. теперь в динамике будем считать $ans[i]$ "--- количество способов разбиения на слагаемые числа $i$ "--- и, перебирая первое слагаемое, будем сводить к более мелким подзадачам.

А если вариант б: разложения, отличающиеся лишь порядком слагаемых, считаем одинаковыми? В переборе уже была у нас полезная идея: учесть это требование можно, потребовав, чтобы в разложении слагаемые были отсортированы. Как мы тут стали бы писать перебор? Опять, наша функция перебирала бы первое слагаемое и запускалась бы рекурсивно, но теперь это слагаемое нужно перебирать лишь до некоторого $k$, где $k$ "--- это предыдущее слагаемое в разложении (т.е. то, которое мы выбрали на предыдущем уровне рекурсии; если мутно, то отвлекитесь и сначала напишите или в уме продумайте реализацию перебора). (Я считаю, что мы потребовали, чтобы слагаемые убывали; если же хотим, чтобы слагаемые возрастали, то перебирать будем от $k$ до максимума "--- до $N$, видимо). Соответственно, теперь параметрами динамики будут $i$ и $k$ и будем считать число способов разбиения числа $i$ на слагаемые, не превосходящие~$k$.

Остальные варианты разбираются аналогично.
|

\task|Найти число правильных скобочных последовательностей, состоящих из $N$ пар скобок. 
[Коротко говоря, правильная скобочная последовательность "--- это последовательность открывающих и 
закрывающих скобок, в которой скобки сбалансированы. (()) "--- это правильная скобочная 
последовательность из двух пар скобок, ()() "--- тоже, а )()( и ())( "--- нет. Я надеюсь, смысл 
определения понятен]. а) Используя только круглые скобки; б) используя круглые, квадратные и 
фигурные скобки: ()[], [\{\}] "--- правильные, а (\{)\} и )()( "--- нет.

Научитесь выводить скобочную последовательность по номеру.
||а) Тут есть два решения. 

Одно основано на понятии баланса, т.е. разницы между числом открывающих и закрывающих скобок в некоторой строке. Строка является правильной скобочной последовательностью, если баланс любого её начала $\geq 0$, а баланс всей строки равен нулю. Ну так давайте для каждого $i$ и $j$ посчитаем, сколько есть строк длины $i$ из символов `(' и `)' с балансом $j$.

Второе вариант "--- правильная с.п. начинается, конечно, на открывающую скобку. Где будет парная к ней закрывающая? Пусть в позиции $2k$ (позиция, очевидно, должна быть чётной), тогда очевидно, что между ними "--- любая правильная с.п. из $k-1$ пары скобок, а после "--- любая правильная с.п. из $N-k$ пар. Дальше просто.

Подумайте, можно ли и как эти решения обобщить на пункт б).
||Про пункт а). В первом решении считаем $ans[i,j]$, при этом при $j>0$ получаем $ans[i,j]=ans[i-1,j+1]+ans[i-1,j-1]$, а при $j=0$ "--- $ans[i,j]=ans[i-1,1]$. 

Во втором решении 
$$
ans[i]=\sum_{k=1}^N ans[k-1]\cdot ans[N-k],
$$
здесь база динамики "--- $ans[0]=1$.

Про пункт б). Первое решение я не знаю, как обобщить, а вот второе "--- легко. Первая скобка может быть любого из 3 видов, и для каждого варианта у нас будет $\sum_{k=1}^N ans[k-1]\cdot ans[N-k]$ последовательностей. Итого
$$
ans[i]=3\sum_{k=1}^N ans[k-1]\cdot ans[N-k].
$$

Можно считать по этой формуле, но вообще сразу понятно, что ответ на задачу б) "--- это ответ на задачу а), умноженный на $3^N$ :).
|

\task|Сколькими способами можно замостить доску $N\times M$ доминошками?
||ДП по профилю.
||Посмотрим заполнение доски $N\times i$, причём в $i$"=ом столбце разрешим некоторым доминошкам вылезать за край доски на одну клетку. То, в каких именно строках они будут вылезать, и будет профилем. Дальше думайте сами, тут немного сложнее обычного определить, какой профиль может следовать за каким.
|

\task|Дана строка $s$, состоящая из букв, и маска $m$. Маска может содержать буквы, символы `\texttt *' и `\texttt ?'. Звёздочка может обозначать любую строку (в т.ч. пустую), а знак вопроса "--- любой символ. Подходит ли данная строка под эту маску?
||Двумерное ДП. Придумайте решение за $O(NM)$.
||Для каждого $i$ и $j$ определим, подходят ли первые $i$ символов строки под первые $j$ символов маски. Если $j$"=ый символ маски "--- буква, то все легко: либо ответ сразу нет, либо надо посмотреть на $ans[i-1,j-1]$. Если знак вопроса, то просто надо посмотреть на $ans[i-1,j-1]$. А вот если звёздочка\dots{} С ходу хочется посмотреть на $ans[i-k,j-1]$ при всех $k$, но можно быстрее, воспользовавшись приёмом сведения циклов к предыдущим подзадачам. А именно, посмотрим на $ans[i,j-1]$ (как будто звёздочка соответствует пустой строке) и на $ans[i-1,j]$ (если звёздочка соответствует непустой строке, то строка на один символ короче тоже подходит под ту же маску). Итого сложность $O(NM)$.

Для базы динамики нельзя просто так ввести нулевые элементы и сказать, что $ans[0,0]=true$, а остальные $false$: если маска начинается со звёздочек, то будут проблемы. Поэтому лучше приписать к маске и к строке в начало одну и ту же букву и только после этого считать $ans[0,0]=true$, а остальные $ans[0,i]=ans[i,0]=false$ (а ответы для первой строки и столбца уже насчитывать по основной формуле).
|

\vspace{0.5cm}

И ещё я дам несколько задач, по которым я почти не буду писать ответы\slash подсказки\slash и т.п.;
в разделе "<Ответы"> вы найдёте только скорее комментарии по их использованию.
Думайте над этими задачами сами :)

\task|При умножении матрицы размера $a\times b$ 
на матрицу $b\times c$ получается матрица $a\times c$, при этом требуется $abc$ умножений чисел. 
Умножение матриц не коммутативно (т.е. матрицы нельзя менять местами: $AB\neq BA$), но ассоциативно 
(т.е. в любом выражении можно расставлять скобки как угодно, результат от этого не изменится: 
$A(BC)=(AB)C$). Правда, от расстановки скобок в выражении зависит количество необходимых умножений чисел.
Соответственно, получается задача. Дано выражение $A_1\cdot 
A_2\cdot\ldots\cdot A_n$, где $A_1$, $A_2$ и т.д. "--- матрицы; размер матрицы $A_i$ "--- 
$r_i\times c_i$, при этом $c_i=r_{i+1}$ для всех $i$. Требуется в выражении расставить скобки (т.е. 
указать порядок выполнения действий) так, чтобы потребовалось как можно меньше умножений чисел.
|||||

\task|Дана строка $s_1$. Разрешается за одно действие либо удалить произвольный символ текущей строки, 
либо вставить произвольный символ в произвольное место текущей строки, либо изменить произвольный 
символ текущей строки (на любой символ по вашему выбору). а) Требуется за наименьшее число действий 
получить данную строку $s_2$. б) То же самое, но за каждое действие есть штраф: $d$ за удаление, $i$ 
за вставку и $c$ за замену, требуется минимизировать штраф. в) То же самое, но штрафы зависят от 
того, что это за символы (т.е. штраф за удаление зависит от того, какой символ удаляем и т.д.; все 
эти зависимости заданы во входном файле). г) и т.д.
||||Эта задача может иметь (и имеет) большое применение в различных ситуациях, когда вам нужно 
обрабатывать возможно ошибочный ввод. Например, электронные словари могут быть готовы к тому, что 
пользователь введёт слово с ошибкой, и в таком случае выдавать ему список похожих слов; 
"<похожесть"> будет определяться по алгоритму, аналогичному решению этой задачи. Можно даже 
реализовать пункт в), например, допуская, что перепутать в английском слове буквы `i' и `y', `c' и `k' легко, 
но вряд ли кто перепутает, например, `a' и `p'. Можно и другие идеи подключить, например допустить 
замену `oo' на `u' "--- решаться задача будет аналогично.

Другое аналогично применение "--- системы автоматической проверки орфографии. Здесь тоже в качестве 
возможных вариантов замены надо бы выдавать слова, которые отличаются не сильно; и также можно 
ввести веса для разных операций и разных букв (например, логично считать, что можно перепутать 
буквы, которые расположены на клавиатуре рядом, и т.п.).
|

%

\epigraph{\rm\TeX's line-breaking algorithm
has proved to be general enough to handle a surprising variety of
different applications; this, in fact, is probably the most interesting
aspect of the whole \TeX\ system.%
\footnote{\raggedright Алгоритм \TeX'а для разбиения строк оказывается достаточно всеобщим для того, чтобы 
справиться с удивительным разнообразием различных приложений. Фактически, это, вероятно, наиболее 
интересный аспект в системе \TeX.\\
\hspace{0.3\textwidth}--- Дональд Е. Кнут. Все про \TeX.}
}{Donald E. Knuth. The \TeX book}


\newlength\varunit
\newlength\firstlinehang
{
\refstepcounter{taskcount}%
\taskcaption{Задание~\thetaskcount:}
%Code from TeXbook, with adjusted parshapes
\parfillskip=0pt
\input texts/circle.tex
\it П%\vadjust can't be used in vertical mode, so I had to do it so
\vadjust{\vbox to 0pt{%
\vspace{1.4cm}
\hspace{\textwidth}\hspace{-\firstlinehang}\box0\vss}}%
редставьте себе, что вы пишите систему компьютерной вёрстки. Одной из основных задач у вас 
будет разбиение большого абзаца на строки. Итак, у вас есть длинная строка "--- текст целого 
абзаца. Вам нужно разбить эту строку на куски, каждый из которых будет в итоге отдельной строкой на 
странице. Ясно, что бывают места, где можно делать разрыв строки, есть места, где его даже очень 
хорошо делать, а есть места, где совсем нельзя "--- так что вам по каждой позиции входной строки 
задано, можно ли там делать разрыв строки и, если да, то штраф за этот разрыв. Аналогично, ясно, 
что строки могут получиться слишком сжатыми или слишком растянутыми, поэтому у вас уже есть 
отдельная функция $good(s)$, которая принимает одну строку $s$ и возвращает некоторое число "--- 
штраф за то, чтобы строку $s$ сделать отдельной строкой итогового абзаца (т.е. если $s$ слишком 
короткая или слишком длинная, то штраф будет большой, а если как раз по длине, то маленький). 
а) Как вы будете искать разбиение абзаца на строки, минимизирующее суммарный штраф за строки и за 
разрывы? б) Пусть теперь штраф за одну результирующую строку вычисляется не просто как сумма штрафа 
за растяжение (результата функции good) и штрафа за разрыв, а как"=нибудь хитрее, например, как 
квадрат их суммы. Что вы будете делать в таком случае? в) А теперь вы ещё хотите избежать 
соседства растянутых и сжатых строк, т.е. теперь у вас есть функция $goodpair(s_1,s_2)$, которая 
возвращает дополнительный штраф за соседство строки $s_1$ со строкой~$s_2$. Как тут быть? 
д) А ещё вы хотите, чтобы последняя строка 
абзаца была не слишком короткой\dots%
\footnote{Идея и код для фигурного абзаца "--- из \TeX book.}

}

\let\afterwriteans\relax
\writeansno{\tsk}|Задание про форматирование абзаца.|

\vspace{0.5cm}

\epigraph{Вы не ужасайтесь\dots{} реально все тривиально\dots}{}

\vfill\pagebreak