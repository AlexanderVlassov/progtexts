% Исходный LaTeX-код (c) Петр Калинин, 2014-
% Код распространяется по лицензии GNU GPL (!)

\documentclass[a4paper,10pt]{problems}
\usepackage{framed}

\begin{document}

\begin{flushright}
Автор: Петр Калинин, основной текст: 2014\\
Этот документ можно распространять по лицензии\\
Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)\\
Последнюю версию, а также исходный код для системы \LaTeX\\
можно скачать с \verb`https://github.com/petr-kalinin/progtexts`\\
\includegraphics[width=2cm]{by-sa-corr.eps}
\end{flushright}

\Header{Тестирование программ}

Тестирование программ, т.е. проверка уже написанной программы на наличие ошибок в них и поиск этих ошибок "--- 
это один из важнейших навыков программиста"=олимпиадника. 
Я бы сказал, что он важнее любого конкретного отдельно взятого алгоритма, а то и группы алгоритмов.

В классических школьных олимпиадах вы весь тур решаете задачи, а проверяются они только после тура. 
(Или во время тура, но вам не сообщают результаты проверки "--- или сообщают, но только на тестах из условия "--- это все не очень существенно отличается.) 
В результате, если ваша программа не пройдет часть тестов жюри, вы никак не сможете это исправить. 
Поэтому на классических олимпиадах тестирование "--- не просто важный, а сверхважный навык.

На современных школьных олимпиадах высокого уровня "--- на международной, всероссийской олимпиадах; также есть слухи (на сентябрь 2014 г.), 
что эта система может быть распространена на региональные (областные) олимпиады, "--- применяется система с <<токенами>>, 
в которой участники могут проверить свое решение на полном наборе тестов во время тура олимпиады.
На такую проверку налагаются определенные ограничения, но тем не менее это, конечно, существенно снижает важность умения тестировать.
Тем не менее все равно навык тестирования остается важным; умея быстро найти тест, на котором ваша программа не работает, вы сможете все ошибки
и исправить быстрее.

В олимпиадах, проводимых по стандарту ACM (это в первую очередь командные олимпиады), участники тоже могут сдавать решения на проверку на полном наборе тестов по ходу тура, но за каждую неудачную попытку начисляются штрафные минуты. 
В дополнение к этому, если решение не проходит хотя бы один тест, оно не засчитывается вообще. 
В результате умение быстро и надежно тестировать здесь также является весьма существенным.

Итак, тестировать нужно уметь и уметь хорошо.

Когда вы решаете задачи "--- не важно, где "--- на учебных занятиях, на олимпиаде или еще где"=либо "--- всегда старайтесь все задачи решать с минимальным числом штрафных попыток. Старайтесь все свои решения проверять максимально тщательно, и воспринимайте любую неудачную попытку как показатель того, что тестируете вы все"=таки неидеально. Радуйтесь всегда, когда сложная задача проходит все тесты с первой попытки, и огорчайтесь, если нет "--- даже если никаких штрафов за неверную попытку не предусмотрено.

Поэтому в этой теме мы обсудим, как же надо тестировать.

\header{Стратегия тестирования}
Конечно, необходимость тестирования и необходимый объем сильно зависят от сложности задачи. 
Если вы пишите задачу, которая для вас очевидно является очень простой, и вы абсолютно уверены, что напишите ее без ошибок, 
то ее скорее всего можно и не очень тщательно тестировать. 
Часто бывает достаточно просто прогнать тест из условия и еще пару тестов "--- и можно сдавать. 
Особенно это относится к ситуации, когда время ценно, а штраф за ошибочную попытку отсутствует "--- как в системе с токенами.

Аналогично, если до конца тура остается пара минут, то вы просто не успеете провести полный цикл тестирования. 
Но если задача не совсем элементарна, или если цена ошибки высока, то тестируйте задачу тщательно. Ни в коем случае не пренебрегайте этим; 
лучше вы потратите лишнее время на тестирование, но не получите штрафа и будете уверены, что задача работает.

\header{Какие тесты надо использовать}
Главное правило тестирования следующее:

\begin{framed}
Тестирование "--- это последовательный, систематический процесс.
\end{framed}

В тестировании должна быть система, тестирование должно быть тщательным и аккуратным. 
Вы не должны тестировать задачу по принципу <<подсуну несколько случайных тестов и посмотрю, разумные ли результаты выдает программа>>. 
Не следует придумывать какие попало тесты, не следует стараться понаворотить в один тест побольше всего интересного. 
Вместо этого надо четко понимать, зачем вы делаете каждый очередной тест, понимать, какие тесты вы будете использовать дальше, и так далее.

Соображения, которые я излагаю ниже, конечно, применимы не к каждой задаче "--- но в каждой задаче смотрите, что из того, что указано ниже, применимо.

\lheader{Минимальные тесты} 
Первым делом подсуньте своей программу \textit{самый маленький тест}, какой только возможен. Это зачастую $N=1$ или даже $N=0$ или что-нибудь подобное. Часто бывает, что такой <<самый маленький>> тест вообще один в своем роде "--- например, существует только одна перестановка из 1 числа, или только один граф без петель с 1 вершиной. Если же нет "--- выберите любой из самых маленьких тестов. Можно даже попробовать два самых маленьких теста; например, если на вход подается массив из $N$ чисел, то попробуйте два теста с $N=1$: когда в массиве единственный элемент равен 1 и когда он равен, например, 137. (А вообще, см. ниже про разнообразие тестов "--- может быть, стоит проверить еще и элемент, равный 0, -1 и -137.) Правда, в этом случае сначала убедитесь, что минимальным тестом не является вообще тест с $N=0$!

(Вообще, многие любят начинать тестирование с теста из условия. На мой взгляд, в большинстве случаев это неправильный подход, почему "--- см. ниже.)

(Однажды ко мне обратился один школьник со словами, что его программа не работает в тестирующей системе, но у него она работает.
Насколько я помню, там вводилось поле $N\times M$ из чисел. 
Я начал тестировать его задачу, введя сначала минимальный тест "--- $N=M=1$, на поле одна единичка. 
Программа зависла.)

После этого чуть увеличьте размер теста (возьмите $N=2$) и постарайтесь протестировать все возможные (!) такие тесты. 
Например, если у вас задана перестановка, проверьте обе возможные перестановки; если граф без петель "--- то все возможные графы с двумя вершинами. 
Как правило, таких тестов не так уж и много, и проверить все не составляет проблем. 
Если же таких тестов бесконечно много, то постарайтесь проверить хотя бы все возможные категории таких тестов. 
Например, в задаче сортировки массива обязательно проверьте случай, когда первое число больше второго, когда оно равно второму и когда оно меньше второго. 
(Это все при $N=2$!) Таких <<категорий>> обычно не так уж и много.

Далее переходите к следующему размеру теста и опять"=таки постарайтесь проверить все возможные тесты или хотя бы все категории тестов. И так далее "--- до тех пор, пока при очередном размере тестов количество возможных тестов или категорий не станет уж очень велико (ну, грубо говоря, больше чем 5--7); часто это бывает уже при $N=3$. В таком случае на этом $N$ проверьте несколько тестов из существенно различных категорий, после чего уже плавно переходите к следущему разделу.

\lheader{Простые маленькие тесты}
Далее попробуйте несколько небольших тестов. Как правило, сюда же попадет тест из условия. 
Старайтесь эти тесты делать различными, добавляя в них те или иные <<фичи>>, которые могут оказаться важны, 
но которые вы толком не смогли протестировать раньше из-за того, что тесты были маленькие. 
Например, это могут быть мосты или циклы в графе, несвязные графы с ненулевым количеством ребер в каждой компоненте связности, 
или сложные "--- сначала возрастающие, потом убывающие, потом опять возрастающие перестановки типа 3 4 1 2, или массивы, в которые есть одинаковые числа, 
но они не соседние (2 1 3 2) и т.п.

\lheader{Разные тесты}
Часто бывает, что в задаче достаточно просто выделяются разные типы, разные варианты тестов. 
Это могут быть даже не <<частные>> случаи, про которые сказано ниже "--- эти типы могут быть явно не выделены
ни в условии, ни в решении, но тем не менее надо подумать и понять, не бывает ли так, что решения задачи в разных ситуациях
чем-то отличаются, нет ли в задаче каких-то возможностей, которые могут бы задействованы не в каждом тесте, и т.д.
Соответственно, надо постараться сделать тесты, которые покроют все эти варианты.

Например, если в задаче есть несколько способов выполнять какое-то действие, и надо такие способы скомбинировать оптимальным образом,
то проверьте по отдельности, что ваша программа умеет выполнять оба способа. 
Пример: задача: дано N резисторов, их можно соединять последовательно и параллельно, надо составить схему с заданным сопротивлением.
Проверьте на простых тестах, что ваша программа может использовать и последовательное, и параллельное соединение "---
подсуньте два теста, в которых надо сделать только одно соединение, и это должно быть а) параллельное; б) последовательное.
Еще пример: игра, в которой есть два типа ходов, надо найти выигрышную стратегию. Проверьте, что ваша программа умеет делать оба типа ходов
"--- просто подсунув тесты, где нужен только один ход "--- по тесту на каждый тип ходов.

Эти варианты могут быть слегка замаскированы. 
Например, задача (простая): проверить, может ли слон дойти за один ход с одной клетки доски до другой.
Слон умеет ходить в четырех направлениях "--- проверьте их все.

Еще пример: Если вы чувствуете, что решения слегка различаются для четного и нечетного $N$, то, пусть даже у вас программа одна,
и у вас там нет проверки на четность $N$ "--- все равно проверьте оба варианта. 
Например: посчитать количество правильных скобочных последовательностей, содержащих ровно $N$ скобок (не \textit{пар} скобок, а именно скобок).
Если $N$ нечетно, то ответ "--- ноль. 
В нормальном решении двумерной динамикой (по паре (количество скобок, баланс)) это получится автоматически, и в программе не будет никаких if'ов,
проверяющих, четно ли $N$. Тем не менее при тестировании не забудьте проверить как четные $N$, так и нечетные.

\lheader{<<Подлые>> тесты}
Подумайте, какие в вашей задаче могут быть <<подлые>> тесты. 
Например, когда решения нет, или когда решение в каком-то смысле пограничное, или не такое, как во многих тестах и т.п.
Если у вас есть в программе особые случаи, то подумайте и о них. 
Протестируйте все такие тесты, при этом старайтесь на каждый случай придумывать не очень большой пример. 
(Не обязательно совсем минимальный, но и не надо лишних наворотов.)

\lheader{Пороговые тесты}
Часть бывает так, что в вашей задаче есть тесты, где при небольшом изменении входные данных ответ "--- или по крайней мере логика его получения "--- меняются сильно.
Например, задача <<выведите наибольшую степень двойки, которая меньше данного числа $N$>>. 
Ясно, что таким пороговым случаем является случай, когда $N$ само является степенью двойки. 
Например, на всем отрезке $[32,63]$ ответ один и тот же, а вот когда $N$ становится равно 64, ответ резко меняется.
Или, например, в вашей задаче есть ровно два <<пути>>, и вам нужно выбрать минимальный "--- тогда пороговой оказывается ситуация,
когда оба пути имеют одинкаовую длину: тут при вариации входных данных минимальным будет становиться то один путь, то другой.

Обязательно протестируйте такие тесты, причем не только сам пороговый тест, но и $\pm 1$ от него, а то и $\pm 2$. 
Например, в задаче про степень двойки обязательно протестируйте числа 63, 64, 65, а может быть, еще и 62 и 66 "--- 
чтобы убедиться, что переход на новый ответ или вариант его получения происходит в правильный момент.

\lheader{Крайние случаи}
Это фактически частный случай предыдущего пункта, но иногда удобнее думать о крайних случаях отдельно. 
Это, например, ситуации, когда решение только-только появлось, т.е. чуть изменить входные данные "--- и решение пропадет; или когда, например,
решение использует все данные элементы, и т.п.

Кроме того, сюда же можно отнести ситуации, когда только один из параметров входных данных является минимальным возможным. 
Например, если вам дана матрица, то полезно проверить, как ваша программа будет работать на размерах $N\times 1$ и $1\times M$ 
(а еще и с нулевым размером, если это допустимо)\footnote{См. реальный пример: \verb`http://acm.sgu.ru/forum_action.php?id=837&all=1`}; 
если у вас граф "--- то как программа будет работать, если вершин несколько, а вот ребро только одно;
если граф с петлями, то, конечно, надо проверить разные графы с одной вершиной (хотя это можно считать еще и <<минимальными>> тестами).

\lheader{Частные случаи}
Если задача имеет какие-то частные случаи, то, конечно, надо их проверить все. 

А именно, во-первых, бывает, что в самом условии задачи указаны различные случаи.
Например, бывают геометрические задачи, где требуется определить взаимное расположение объектов, 
типа <<если прямые пересекаются, то выведите их точку пересечения;
если они параллельны, то выведите то-то; если совпадают, то выведите то-то>>. 
Бывает, что и в формате входных данных присутствуют какие-то варианты.
Конечно, надо проверить их все.

Но не менее важно проверить и все варианты, которые есть в вашей программе. Если случай, допустим, $b=0$ вы рассматриваете особо, 
т.е. у вас в программе стоит \verb`if b=0`, "--- конечно, надо этот случай тщательно протестировать. 
Причем этот случай тоже надо тестировать полноценно \textit{систематически}. 
В простейшем случае "--- если $b$ задано во входных данных, и если $b=0$, то следует простой вывод "--- достаточно проверить один или несколько таких тестов.
Но если в случае $b=0$ у вас отдельная сложная логика, то, значит, этот случай надо тщательно протестировать "--- начиная с минимальных тестов 
(минимальных среди тех, у которых $b=0$), небольших тестов, пороговых и т.д.

Аналогично, если значение $b$ берется не из входного файла, а вычисляется сложной логикой, то нужно постараться придумать полноценный набор тестов,
начиная с минимальных и т.д., во всех в которых будет получаться $b=0$, и их все проверить.

Конечно, это относится к любому частному случаю, фактически к любому \verb`if`, который у вас есть в программе. 
Вы должны быть уверены, что в процессе вашего тестироваться \textit{каждая строчка программы} исполнилась хотя бы один раз (а лучше "--- много раз).
Более того, хорошо бы покомбинировать возможные пути исполнения, возможные частные случаи. 
Например, если у вас идет сначала частный случай $a=0$, а потом частный случай $b=0$, и при этом возможны все четыре комбинации пар $(a,b)$ 
(т.е. следующие комбинации: $(0,0)$; $(0, \neq 0)$; $(\neq 0, 0)$; $(\neq 0, \neq 0)$), то все четыре и надо протестировать.
Конечно, если \verb`if`'ов у вас много и они могут проходить во множестве разных порядков, то число таких комбинаций может быть очень велико
и все вы их не протестируете "--- но протестируйте основные.

\lheader{Максимальные тесты}
Почему-то многие люди, даже тщательно проверив все изложенное выше, пренебрегают тестированием на максимальных тестах.
Это неправильно. Протестировать несколько макстестов не так уж и сложно, зато позволяет избежать возможных ошибок.

Бывают задачи, в которых максимальный тест можно ввести вручную "--- например, если на вход подается только одно число.
Тогда возьмите и введите этот максимальный тест.

Но в большинстве задач максимальный тест имеет большой размер "--- значит, вам придется написать отдельную программу"=генератор этого теста. 
Ничего сложного в этом нет; если в вашей задаче, например, на вход подается число $N$, а потом массив из $N$ чисел, то напишите простую программу,
которая выведет во \textit{входной} файл максимально возможное $N$, а потом сколько надо единиц. 
Или возрастающую последовательность от 1 до $N$. 
Или $N$ случайных чисел "--- но это немного хуже, почему "--- я напишу ниже.

Что надо проверять на макстесте? 
Во"=первых, зачастую вы сможете даже проверить точный ответ на задачу. 
Например, в задаче сортировки массива вы можете подсунуть последовательность от $N$ до 1, и проверить, что в выходной файл ваша основная программа
вывела последовательность от 1 до $N$.

Во"=вторых, вы можете по крайней мере проверить разумность ответа. 
Если вы суммируете в программе положительные числа, то отрицательный ответ должен вас заставить задуматься и пойти искать в вашей программе арифметическое переполнение. И не только отрицательный, но и слишком маленький тоже. Если вы сортируете массив, и подали на вход случайную последовательность чисел, то вывод, начинающийся с кучи нулей, вас тоже должен насторожить. (Ну, конечно, если вы уверены, что у вас не было столько нулей во входных данных.)

В"=третьих, вы можете проверить свою программу на переполнение различных массивов. 
На паскале это делается автоматически, не забудьте только поставить ключ компилятора \verb`{$r+}`.
На си это существенно сложнее, но вы можете обнаружить какие-нибудь странные результаты;
а если вы очень сильно вылезли за границы массива, то вы получите сообщение об ошибке типа <<программа выполнила недопустимую операцию>> (под Windows),
или просто <<Segmentation fault>> (segfault) под Linux. 
Кстати, в ряде случаев эти ошибки (под Linux) можно обнаружить утилитой valgrind, если она установлена у вас на компьютере, см. отдельный раздел ниже.

И в"=четвертых, вы проверите время работы вашей программы. 
Во многих задачах это не является проблемой, и вы заранее уверены, что программа уложится в ограничение времени, 
но так бывает не всегда, и проверить лишний раз не мешает.

Когда вы готовите макстест, надо иметь в виду еще и вот что. 
Бывают просто максимальные тесты, которые являются максимальными просто по формальному тексту условия.
А бывают тесты, которые максимальны именно для вашего решения "--- например, на которых ваше решение работает дольше всего,
или на которых оно использует наибольшее количество памяти, и т.п.

Так вот, тестировать надо и те тесты, и другие. 
Например, если входные данные "--- это массив из $N$ чисел ($N\leq 1000$), то все тесты с $N=1000$ будут формально максимальными.
Но при этом может оказаться, что ваша программа медленне работает, если массив упорядочен, или если все числа в массиве одинаковы.
Более того, может оказаться, что при $N=1000$ ваша программа работает быстро и не требует много памяти, а вот при $N=999$ "--- 
намного медленнее и требует больше памяти потому, что это нечетное число (по тем или иным причинам). Или, например, при $N=997$ 
(наибольшее простое число до 1000). Конечно, в таком случае над тестировать и $N=1000$, и $N=999$ или 997.

\header{Дополнительные принципы тестирования}
\lheader{Знайте ответ на тест заранее} Прежде чем запускать программу на некотором тесте, посчитайте ответ на этот тест вручную. 
Тестировать программу на тесте, на который вы не знаете ответ "--- наполовину, если не больше, бессмысленно.
При этом ответ надо посчитать заранее, потому что если вы уже знаете ответ, выведенный программой, 
то вы будете пытаться не решить задачу самостоятельно, а объяснить ответ программы "--- и с высокой вероятностью <<объясните>>, 
даже если ответ программы неверный.

В частности, это обозначает, что следует избегать тестов, на которые вы не можете вычислить ответ. 
Если, например, у вас в задаче граф, не следует рисовать какой попало граф с 10-20 вершинами, запускать на нем вашу программу, смотреть на ответ и думать:
<<Да, похоже на правду...>> Лучше нарисуйте граф, на который вы сможете посчитать ответ, или все-таки потратьте время и найдите ответ на задачу 
на вашем графе ДО запуска программы.

Этот же принцип относится и к максимальным тестам. Может показаться, что на макстест вы не можете найти ответ <<руками>>, но зачастую бывает,
что на некоторые тесты определенной структуры вы найти ответ сможете. 
Например, если вам надо посчитать сумму $N$ введенных чисел, то если вы будете тестировать на случайных числах, то вы не сможете вычислить ответ. 
А если вы будете тестировать на последовательности натуральных чисел от 1 до $N$, то сумма их находится легко "--- это сумма арифметической прогрессии.
Аналогично, ответ на какую-нибудь задачу на случайном графе найти сложно, а на полном графе, или на графе, представляющем из себя просто цикл из $N$ вершин,
"--- может оказаться намного проще.

Поэтому я и не советую тестировать на случайных тестах. 
Тестируйте лучше на тестах с регулярной структурой, на которых вы можете аналитически найти ответ.
(На случайных тестах тоже может быть полезно тестировать, но только как дополнение к тестам с регулярной структурой.)

\lheader{Разнообразие тестов} Старайтесь вносить разнообразие в ваши тесты "--- старайтесь, чтобы используемые вами тесты не были слишком однотипны,
чтобы в них было как можно меньше всего общего.

Конечно, вы и так внесете серьезное разнообразие за счет варьирования $N$ и рассмотрения различных приведенных выше случаев. 
Но старайтесь вносить разнообразие и далее. 
Например, если входные данные "--- это $N$ и $N$ различных чисел, то не следует тестировать \textit{только} на тестах, на которых эти $N$ чисел являются
перестановкой. 
Например, если вы тестируете варианты с $N=2$, то не следует удовлетвориться вариантами <<1 2>> и <<2 1>>. 
Попробуйте еще и <<100 997>> и <<-5 -8>> (если это допустимо, конечно). 

Если у вас задан граф и вершина в нем (<<начальная вершина>>), то не забывайте, что она может иметь номер, отличный от 1. 
Казалось бы, вашему алгоритму все равно, какая начальная вершина "--- вы считали ее номер и дальше используете эту переменную "---
но тем не менее не помешает этот номер варьировать.

Если вам заданы $N$ чисел, вводите их в разном порядке: возрастающем, убывающем, и т.п. "--- даже если вам кажется, что вашему решению порядок входных данных не важен. 
Если задана матрица, то не забывайте, что она может не быть квадратной, и т.д. 
Если задан круг, не забывайте, что его центр может быть и не $(0,0)$.
Если задано $N$, то не забывайте, что оно может быть как четным, так и нечетным "--- даже если вроде в задаче это не имеет значения.

И так далее.

Чем это отличается от того, что я писал выше? Выше я призывал вас последовательно и максимально полно рассматривать всевозможные случаи. 
Рассматривать случай $N=1$, рассматривать все возможные тесты с $N=2$, рассматривать крайние случаи, особые случаи и т.д. 
Но это все касалось тех ситуаций, когда довольно очевидно, что это важные варианты и что от них реально может что-то зависеть.

В этом же разделе я призываю вас думать также о тех вариантах, от которых, казалось бы, ничего не зависит. 
Конечно, не надо перебирать абсолютно все возможные такие варианты (не следует перебирать на каждом тесте все возможные порядки нумерации вершин графа, например). 
Но полезно от теста к тесту двигаясь по изложенному в предыдущих разделах алгоритму, не забывать варьировать те параметры, от которых, казалось бы,
ничего не зависит (т.е. стоит в каждом новом тесте как-нибудь по-новому нумеровать вершины графа).

\lheader{Ориентируйтесь не на формальность условия, а на смысл} 
Бывает так, что ваша программа может работать для тестов, выходящих за рамки формата входных данных.
Например, в условии написано $N\geq 1$, но вы понимаете, что при $N=0$ задача тоже имеет смысл и вроде ваша программа должна бы работать "---
так и протестируйте на $N=0$. 

\lheader{<<Белый ящик>> и <<черный ящик>>} Есть два принципа тестирования программ "--- прицип <<черного ящика>> и <<белого ящика>>. 
Первый подразумевает, что вы не знаете внутреннего устройства программы, и тестируете только исходя из знания задачи. 
Второй же подразумевает, что вы внутреннее устройство программы знаете.

Так вот, вы должны сочетать оба способа. 
Я про частные случаи этого правила уже писал выше: при тестировании частных случаев надо тестировать как те, которые очевидно следуют из условия,
так и те, которые вам пришлось разобрать в коде.
Аналогично, макстесты надо брать и те, которые максимальны с точки зрения условия, так и те, которые максимальны с точки зрения вашей программы.

Но это же относится и ко всему остальному тестированию. 
Например, крайние и пороговые случаи также бывают как с точки зрения условия, так и с точки зрения вашей программы.

\lheader{Не теряйте тесты} Если вы уже протестировали вашу программу на многих, особенно не очень тривиальных, тестах, то не теряйте эти тесты. 
Возможно, вы найдете в программе ошибку, и вам придется все тестировать заново. Поэтому старайтесь тесты так или иначе сохранять.

Полезный прием "--- если задача не требует чтения входного файла <<до конца файла>>, то в конце файла может быть произвольный мусор. 
Например, если формат входного файла <<сначала задано число $N$, а далее идут $N$ чисел>>, то скорее всего вы напишите программу так, 
что она будет полностью игнорировать все, что идет после этих $N$ чисел. 
Тогда во входном файле вы можете легко держать несколько тестов сразу "--- программа будет просто подцеплять первый из них. 
Когда вам надо протестировать на очередном тесте, вы его просто переносите в начало входного файла.

(А если бы формат входного файла был бы просто <<входной файл содержит несколько чисел>>, то вам бы пришлось читать <<до конца файла>>, и такой трюк не прошел бы
"--- или как минимум был бы существенно сложнее.)

\lheader{Стресс"=тестирование}
Особый вид тестирования "--- это так называемое стресс"=тестирование. В широком смысле "--- это любое тестирование на огромном количестве тестов; но в узком смысле олимпиадного программирование "--- это тестирование, организованное следующим образом.

Вы пишите по задаче два решения "--- одно основное, которое вы собственно и хотите протестировать; второе <<тупое>>, которое работает медленно, но максимально надежно. 
В <<тупом>> решении важно действительно все писать максимально тупо, стараясь использовать как можно меньше предположений и утверждений, 
которые вы можете предполагать по задаче; часто говорят, что <<тупое>> решение "--- это просто перевод условия задачи на язык программирования.
Часто в качестве <<тупого>> решения подходит рекурсивный перебор. 
Старайтесь не заимствовать никакой код из <<тупого>> решения в основное и наоборот, чтобы не переносить баги.

Кроме того, вы пишите генератор случайных небольших (чтобы <<тупое>> решение работало) тестов и программу (<<чекер>>), сравнивающую ответы двух ваших решений,
и все это в цикле запускаете: генератор"---два решения"---чекер"---генератор"---и т.д. 
Даете этой связке поработать некоторое время "--- либо пока не найдется тест, на котором два решения дадут разные результаты,
либо пока не пройдет какое"=то время, будет проверено много тестов, и вы не решите, что хватит.  
Зачастую стресс"=тестирование, особенно если оно работает больше минуты без ошибок, можно запускать в фоновом режиме, пока вы работаете над другими задачами.

Так за небольшое время вы можете проверить тысячи тестов. 
Если в вашем решении есть ошибки, которые встречаются сравнительно часто, то, скорее всего, вы их найдете.
(Правда, конечно, надо всегда помнить, что стресс"=тестирование "--- не замена полноценному последовательному тестированию и может найти далеко не все ошибки.)

Как организовать такой запуск в цикле? 
Можно, конечно, написать скрипт (.bat/.cmd или .sh-файл), но можно и проще. 
Все делаете в одной программе. Пишите четыре процедуры (функции). 
Процедура"=генератор генерирует очередной тест и (важно!) сохраняет его во входной файл.
Две процедуры решения (основное и <<тупое>>) каждая читает входной файл (!), решает задачу и выводит ответ: основное решение "--- в основной выходной файл,
<<тупое>> "--- в какой"=нибудь еще файл.
И процедура"=чекер считывает оба файла и сравнивает результаты.

И в основной программе вы просто в цикле запускаете эти процедуры.

Важно то, что все общение между процедурами ведется через файлы. 
(Например, можно было бы сделать так, чтобы генератор сразу заполнял массив в памяти, который потом использует решение,
или чтобы черек ответы брал прямо из соответствующих переменных "--- но так делать не надо.)
Это позволяет вам, во"=первых, протестировать не только собственно алгоритм, но и ввод"=вывод.
А во"=вторых, это позволяет вам потом очень легко переделать программу на окончательное решение, которое вы будете сдавать "---
вы просто в основной программе цикл с вызовами кучи процедур замените на вызов процедуры основного решения; 
в процедуре основного решения ничего исправлять не надо будет!

Есть еще один момент, который надо иметь в виду при стресс"=тестировании. 
Если таки найдется тест, на котором ваши программы дали разные результаты, то вам нужно суметь этот тест не потерять. 
Поэтому в любой реализации стресс"=тестирования надо, чтобы, как только чекер определил, что результаты различаются,
он должен тут же прерывать тестирование. 
Во второй реализации (все в одной программе) это просто: чекер будет просто тут же завершать программу.
В первой реализации (через скрипты) чекер будет должен возвращать ненулевой код возврата, 
а в скрипте вы должны будете это проверять. 
Главное "--- сделать все так, чтобы когда стресс"=тестирование остановлено, у вас во входном файле
как раз оказался бы найденный тест, а в выходных файлах "--- результаты работы обеих решений.
Кстати, это еще одна причина, почему генератор и чекер должны общаться с решениями через файлы, даже если вы реализуете все в одной программе "---
так вам намного проще посмотреть тест, на котором решения разошлись.

Стресс"=тестирование "--- это, конечно, не самый быстрый процесс. 
В отличие от простого тестирования, описанного в предыдущих пунктах, подготовка и запуск стресс"=тестирования занимает немало времени.
Поэтому я считаю, что стресс"=тестирование надо рассматривать как дополнительную возможность, которую использовать стоит не всегда.
Если у вас есть возможность проверить свою программу на тестах жюри во время тура (система с токенами, или командная олимпиада), 
и вы уже тщательно ее оттестировали вручную, то, возможно, стоит и отправить ее на проверку "--- возможно, стресс и не понадобится.
Если задача на тестах жюри не работает, и вы не можете найти ошибку "--- тогда и стоит написать стресс.

Если же отправить решение на тестирование во время тура возможности нет, то следует здраво оценить ситуацию, и решить, что стоит делать:
писать стресс по этой задаче или работать над другими задачами. 
Здесь, конечно, универсального рецепта нет, все зависит от многих параметров, 
в том числе от того, насколько вы уверены в своем решении по этой задаче, насколько просто написать генератор"---тупое решение"---чекер по ней,
и как вы оцениваете свои шансы успешно написать другую задачу (задачи) за оставшееся от тура время. 
Но, если таких <<других задач>> уже не осталось, т.е. если вы уже написали все задачи тура, а время еще есть "--- то вот тут самое правильное "---
это как раз написать стресс"=тестирование, сначала по одной задаче, потом "--- и по другим.

В общем, если стратегия применения обычного тестирования достаточно проста, то над тем, когда и как применять стресс на реальных олимпиадах,
надо думать в зависимости от ситуации.

И последнее. Что должен из себы представлять чекер? 
Самый простой вариант "--- он должен просто сравнивать два решения, найденные двумя программами, и прерывать работу стресс"=тестирования,
если они различаются.
Но это далеко не всегда возможно; простейшие пример "--- если в задаче требуется найти оптимальное решение, и таких решений может быть несколько,
то две ваших программы легко могут найти два разных решения и обе оказаться правы.
В таком случае, конечно, идеальный вариант "--- чекер должен проверять корректность решения основной программы, используя вывод тупого решения как подсказку. 
Например, чекер проверит, что стоимости обоих решений совпадают, и проверит, что решение основной программы корректно и имеет нужную стоимость.
(Собственно, примерно так и работают чекеры, подготовленные жюри для финального тестирования, только вместо вывода тупого решения они используют
вывод решения жюри.)

Но такой чекер написать бывает сложно. Тогда можно поступать и по"=другому, написав чекер, который не до конца проверяет корректность ответа.
Например, можно проверять только стоимость, не проверяя самого решения.
Конечно, стресс"=тестирование с таким чекером найдет меньше ошибок, но все равно может быть полезным.

В пределе такой подход приводит к тому, что в определенных случаях можно проводить стресс"=тестирование и без тупого решения вообще.
Например, вы можете просто проверять корректность ответа (например, что выведенный путь существует в графе), и что он соответствует той стоимости,
которую вывело ваше решение, но не проверять, что этот ответ оптимальный. 
Или, например, если надо найти точку пересечения двух отрезков, вы можете проверять, что выведенная точка действительно принадлежит
обоим отрезкам "--- тогда вы не сможете отловить ситуации, когда ваше решение выводит <<отрезки не пересекаются>>, хотя они на самом деле пересекаются,
но остальные ошибки отловить сможете.

Важный случай такого стресст"=тестирования без тупого решения "--- это если надо не проверять корректность ответа, а проверять, 
завершается ли вообще ваше решение корреткно. 
Например, укладывается ли оно в ограничение времени, не падает ли оно с ошибкой, или не нарушает ли оно формат выходных данных на определенных тестах.
В первых двух случаях вам даже не нужен и чекер, в последнем случае чекер будет просто проверять формат выходных данных.
Этот подход особенно полезен, если вы уже сдавали решение на проверку, и получили вердикт, что оно прошло все тесты, кроме некоторых,
на которых, упало с ошибкой, или нарушило формат выходных данных, или превысило предел времени (правда, в последнем случае, конечно,
надо сначала постараться просто потестировать на больших тестах).

При этом, если вы проверяете, укладывается ли ваше решение в ограничение времени, вы, конечно, можете встроить в код стресс"=тестирования
проверку на время работы, но можете "--- для получения грубых результатов "--- просто после завершения каждого теста выводить что"=нибудь
на экран, глазом смотреть, сколько времени занимает каждый тест, и просто прервать программу, если прошло несколько секунд,
а тест еще не решен. 
Кроме того, конечно, в этом случае вам надо, чтобы генератор создавал не маленькие тесты, а близкие к максимальным.

Но еще раз подчеркну, что стресс"=тестирование не способно найти все ошибки. 
Поэтому его следует рассматривать только как дополнение к основному тестированию, но не как его замену.
Кроме того, это обозначает, что, если стресс"=тестирование в течение некоторого времени не нашло ни одной ошибки,
то может иметь смысл поменять параметры генератора "--- например, генерировать тесты с б\'{о}льшим $N$, или немного другой структуры и т.п.


Разделы в стресс-тестировании
Почему не тест из условия

Думать во время написания кода
Упрощать код
Перечитать задачу

valgrind

\inputanswers

\end{document}
