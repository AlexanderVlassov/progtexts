% Исходный LaTeX-код (c) Пётр Калинин, 2014-
% Код распространяется по лицензии GNU GPL (!)

\documentclass[a4paper,10pt]{problems}
\usepackage{framed}
\usepackage{verbatim}
\let\eps\varepsilon


\begin{document}

\begin{flushright}
Автор: Пётр Калинин, основной текст: 2014\\
Этот документ можно распространять по лицензии\\
Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)\\
Последнюю версию, а также исходный код для системы \LaTeX\\
можно скачать с \verb`https://github.com/petr-kalinin/progtexts`\\
\includegraphics[width=2cm]{by-sa-corr.eps}
\end{flushright}

\Header{Двоичный поиск}

Двоичный поиск, он же бинарный поиск, он же алгоритм деления пополам или дихотимия "--- это целая серия алгоритмов, объединенных одной идеей. 
Мы их последовательно рассмотрим.

\header{Вещественный двоичный поиск}

\lheader{Прочность нити на разрыв}
Для начала рассмотрим следующую задачу "--- не совсем по программированию. Пусть у нас есть, например, нитка. 
Мы можем подвешивать к этой нитке различные грузы, при этом если мы подвесим слишком большой груз, то нитка порвется. 
Соответственно, есть некоторый пороговая масса груза $m_0$ такая, что от любой б\'{о}льшой массы нитка рвется, а от любой меньше "--- нет.
Поставим задачу определить эту пороговую массу.

(Может возникнуть вопрос: а что происходит, если масса точно равна $m_0$? 
Будем считать, что происходит что"=то конкретное, что имеет место только один из следующих вариантов: либо при $m_0$ нитка всегда рвется, либо всегда нет.
На самом деле, это нам совершенно несущественно, как будет видно ниже.)

Будем считать, что запасы нитки у нас достаточно велики "--- ее хватит на проведение большого количества экспериментов.
Будем также считать, что нитка абсолютно невесома (не рвется под своей тяжестью) и однородна, 
т.е. для любого ее куска пороговая масса одна и та же "--- все-таки у нас олимпиады по программированию, а не по физике%
\footnote{Реальные нитки неоднородны и $m_0$ зависит от куска. 
См. \textit{Всероссийские олимпиады по физике, 1992-2001} под ред. С.~М. Козела, В.~П. Слободянина, часть 2, задача 10.17.}%
.
Также будем считать, что нас доступны грузы абсолютно любой (неотрицательной, конечно) массы, с бесконечной точностью 
(т.е. что мы, например, можем сделать груз массы ровно $20\pi+137,035999074$ грамм.

Итак, постараемся определить $m_0$ за минимальное число экспериментов. 
Точнее, конечно, \textit{абсолютно точно} определить $m_0$ у нас не получится, т.к. для этого надо определить бесконечное число десятичных знаков, 
которые могут быть в записи $m_0$. 
Поэтому выберем маленькое число $\eps$ и постараемся найти $m_0$ с точностью $\eps$, 
т.е. найти такие $l$ и $r$, что $l\leq m_0\leq r$, но $r-l\leq \eps$.

Алгоритм достаточно прост. Мы знаем, что если к нити не подвешивать груз (т.е. подвесить груз массы $0$), то она не порвется. 
С другой стороны, будем считать, что мы знаем такую массу $M$, при которой нить точно порвется 
(например, если это обычная швейная нить, то вряд ли она выдержит груз массой 1 тонну).
Соответственно, обозначим эти две величины как $l$ и $r$ и далее будем их корректировать. 
А именно, на каждом шагу алгоритма возьмам среднее арифметическое масс $l$ и $r$ и поставим эксперимент: порвется нитка от такой массы или нет? 
Если порвется, то корректируем границу $r$, иначе $l$:
\begin{codesampleo}\begin{verbatim}
l:=0;
r:=m_big;  // та самая масса M, при которой нить точно рвется
while r-l>eps do begin    // eps --- требуемая точностью
    m:=(r+l)/2;
    if (нить рвется от массы m) then
        r:=m
    else l:=m;
end;
\end{verbatim}
\end{codesampleo}

В результате у нас \textit{всегда} при выполнении алгоритма будет так, что от массы $r$ нить рвется, а от массы $l$ "--- нет. 
В итоге мы и найдем такие $l$ и $r$, что $r-l\leq eps$, и $l\leq m_0\leq r$.

Вернемся к вопросу о том, что происходит с ниткой при массе, точно равной $m_0$, а именно поймем, почему ответ на этот вопрос нам не важен.
Действительно, во"=первых, крайне маловероятно, что в некоторый момент выполнения алгоритма у нас $m$ будет точно равно $m_0$.
Мы ведь проверяем конечное число значений, а $m_0$ может быть любым вещественным числом "--- чтобы мы попали точно в $m_0$,
нам должно очень крупно повезти (строго говоря, вероятность этого "--- например, с учетом случайности отношения $M/m_0$ "--- точно равна нулю).
Но во"=вторых, пусть даже на очередной итерации у нас получилось $m=m_0$, и пусть нитка порвалась. 
Тогда у нас будет $r=m_0$, и при всех дальнейших экспериментах нитка рваться не будет, т.к. везде далее будет $m<m_0$,
в итоге получим $r=m_0$ и $l\approx m_0-\eps$ "--- все равно $m_0$ мы с нужной точностью нашли. 
Совершенно аналогично, если бы при $m=m_0$ нитка не порвалась бы, то мы получили бы $l=m_0$ и $r\approx m_0+\eps$ 
"--- в пределах заданной точности решение то же самое.

Какова сложность алгоритма? Сложность, конечно, будет измерять в количестве экспериментов.
Изначально $r-l=M$, в конце $r-l\approx \eps$, каждый раз $r-l$ уменьшается в два раза,
поэтому общее количество итераций будет примерно $\log_2 (M/eps)$. 
Это не очень много; например, если $M=1e20$, а $eps=1e-20$, то $\log_2 (M/eps)\approx 133$.

\lheader{Общая идея} 
Итак, общая идея уже достаточно понятна. 
Пусть у нас есть некоторый критерий, определяющий, что некоторые вещественные числа являются в каком"=то смысле <<хорошими>>, а некоторые "--- <<плохими>>,
причем все хорошие идут до всех плохих. 
Нам надо определить пороговое значение, где хорошие числа становятся плохими.

Мы поступаем очень просто: берем некоторые два числа, одно из которых ($l_0$) гарантированно является хорошим, а другое ($r_0$) "--- плохим,
и далее много раз повторяем следующую операцию: вычисляем среднее арифметическое $m$ этих двух чисел и смотрим: хорошее оно или плохое.
Если хорошее, то мы можем присвоить $l:=m$, иначе $r:=m$. 
В итоге у нас постоянно $l$ будет хорошим, а $r$ плохим, а на каждом шагу разность $r-l$ будет уменьшаться в два раза 
"--- за примерно $\log_2(M/\eps)$ итераций (где $M$ "--- начальное значение разности $r-l$) мы достигнем точности $\eps$.

Общий алгоритм выглядит почти так же, как и приведенный выше:
\begin{codesampleo}\begin{verbatim}
l:=l0;
r:=r0;
while r-l>eps do begin    
    m:=(r+l)/2;
    if good(m) then
        l:=m
    else r:=m;
end;
\end{verbatim}
\end{codesampleo}

Здесь \verb`good(x)` "--- функция, возвращающая \verb`true`, если $x$ "--- хорошее число, и \verb`false` "--- если плохое. 
Вообще, всегда, когда пишите деление пополам, выносите проверку <<хорошести>> числа в отдельную функцию, чтобы не загромождать основной цикл.
(Исключение см. в следующем разделе.)

Как и в примере выше, нам совершенно не важно, является ли порогое число <<хорошим>> или нет.

\lheader{Поиск корня функции}
Существенный частный случай вещественного двоичного поиска (да и вообще многие вещественные двоичные поиски можно объявить частным случаем этого)
"--- это поиск корня монотонной непрерывной функции.
Итак, пусть у нас есть функция $f(x)$, которая монотонно строго возрастает (по крайней мере на интересующем нас отрезке) 
и непрерывна (т.е. не имеет скачков) там же.
И пусть у нас есть такие два числа $l$ и $r$, что $f(l)\leq0$, а $f(r)\geq0$.

Есть соответствующая теорема математического анализа, что в таком случае на отрезке $[l,r]$ у функции есть ноль,
т.е. такое значение $x_0$, что $f(x_0)=0$, причем такое значение $x_0$ единственно. 
Его легко найти двоичным поиском: просто объявляем все такие $x$, что $f(x)<0$, <<хорошими>>,
а все такие $x$, что $f(x)>0$, "--- <<плохими>>. 
(Как и раньше, нам не важно, каким определить собственно то единственное $x_0$, для которого $f(x_0)=0$.)
И легко пишем алгоритм:
\begin{codesampleo}\begin{verbatim}
while r-l>eps do begin    
    m:=(r+l)/2;
    if f(m)<0 then   // можно и <=
        l:=m
    else r:=m;
end;
\end{verbatim}
\end{codesampleo}

Здесь в условии if'а стоит сравнение $f(m)<0$. 
Это "--- то самое исключение, про которое я писал в предыдущем разделе: если вы ищете корень функции, то можно в поиске в if'е написать
сравнение функции с нулем. Но само вычисление $f(m)$ все равно вынесите в отдельную функцию.

Аналогично можно искать и корень уравнения $f(x)=c$, если вы знаете, что $f(l)\leq c$, а $f(r)\geq c$.

\lheader{А если функция не монотонна или не непрерывна?}
Если функция строго возрастает, но разрывна, то есть риск, что у нее нет корня: что в некоторый момент она делает скачок сразу от отрицательного
значения до положительного (т.е. например $f(x)<0$ при $x\leq x_0$, но $f(x)>0$ при $x>x_0$). 
Но тогда наш алгоритм тоже срабатывает вполне разумно: $l$ и $r$ в итоге будут ограничивать $\eps$"=окрестность этого скачка.

Если функция монотонна, но убывает, а не возрастает, то решение тоже понятно: надо просто изменить знак проверки в \verb`if`, ну или
поменять местами присваивания $l$ и $r$. 

Если заранее неизвестно, возрастает функция или убывает (но известно, что она монотонна), то, конечно, надо ориентироваться на знаки $f(l)$ и $f(r)$.
Можно заранее запомнить знак $f(l)$, но можно написать проще: просто в условии if'а написать \verb`if f(l)*f(m)>0 then l:=m...`.
Это даже легко понять: мы поддерживаем ситуацию <<$f(l)$ и $f(r)$ имеют разные знаки>>.

Наконец, еще один важный случай "--- если функция не является монотонной, но все равно изначально $f(l)$ и $f(r)$ разных знаков. 
Тогда аналогичный алгоритм найдет \textit{какой"=нибудь} ноль (ну или скачок через ноль, если функция может быть разрывна).
При этом, если мы заранее знаем, что $f(l)\leq 0$, а $f(r)\geq 0$, то в if'е можно писать условие $f(m)<0$, 
если же мы только знаем, что $f(l)$ и $f(r)$ разных знаков, то либо надо заранее запомнить, кто какого знака, 
и учесть это в if'е (примерно так: \verb`if (f(m)<0) xor (flag)`, здесь \verb`flag` обозначает, что изначально было $f(l)>0$), 
либо писать \verb`f(l)*f(m)`.

Общее всех этих случаев "--- что у нас изначально $f(l)$ и $f(r)$ разных знаков. 
Если это не так, то мы вообще не можем гарантировать наличия нуля, и метод деления пополам нам особенно не поможет.
Можете подумать, какой у него будет результат, если условие разных знаков изначально не выполнено.

\lheadernd{Что выводить?} Действительно, что нам надо выводить как результат работы программы, т.е. как найденное значение $x_0$?
Можно выводить и $l$, и $r$ "--- если нам надо было найти решение с точностью $\eps$, то оба эти значения подходят.
Если вы боитесь попасть <<на грань>> точности, то просто сделайте в программе $\eps$ в несколько раз меньше чем требуется.


\lheader{Решение без $\eps$} Вместо того, чтобы гнать цикл пока $r-l>\eps$, можно его выполнять, например, строго определенное количество раз.
Например, можно его выполнять 100 раз "--- тогда гарантированно $r-l$ уменьшится в $2^{100}$ раз, чего очень часто бывает достаточно.
Ну или сделайте цикл еще больше раз, если $2^{100}$ вам мало. 
Это в некотором смысле обеспечивает вам наилучшую точность, которая достижима при данном количестве вычислений функции;
если вместо количества итераций просто поставить отсечение по времени, то вы получите наилучшую точность, которая достижима за это время.

\lheader{Выбор $l$ и $r$} Как уже многократно говорилось, надо выбрать $l$ и $r$ так, чтобы $l$ было <<хорошим>>, а $r$ "--- <<плохим>>
(в случае с функцией "--- чтобы $l$ и $r$ были разных знаков). 
В общем случае это нетривиальная задача, в каждом конкретном случае надо думать особо.

Бывает так, что границы заданы довольно естественно просто по смыслу области определения функции $f(x)$;
например, если мы решаем методом деления пополам уравнение $\tg x=a$ при некотором $a$ 
(можно было бы просто взять арктангенс, конечно, но для примера рассмотрим решение методом деления пополам), 
то мы можем взять $l=-\pi/2$, $r=\pi/2$ "--- обратите внимание, кстати, что нам все равно не придется вычислять $f(l)$ и $f(r)$, поэтому не страшно,
что функция в этих точках обращается в бесконечность.

Бывает так, что границы легко найти; например, если мы решаем уравнение $x^2=a$ при некотором $a$
(аналогично, можно было бы извлечь корень, но для примера поговорим про деление пополам), то понятно,
что нас устраивают $l=0$, $r=a$.

Но важно также понимать, что совершенно не страшно завысить начальные значения $l$ и/или $r$ даже на несколько порядков величины
"--- все равно деление пополам очень быстро сходится.
Например, пусть вы знаете, что $f(0)\leq 0$ (и поэтому берете $l=0$), но вам сложно оценить, при каком $r$ получится $f(r)\geq 0$.
Бывает так, что вы понимаете, что в вашей задаче ответ не может быть больше, например, $1e20$ (вообще, это должна быть
какая-то нетривиальная задача, чтобы ответ был больше $1e20$, если все входные данные не очень велики), то берите $r=1e20$.
Или даже $1e100$. 
Это все не очень страшно, вы просто добавите себе пару сотен лишних итераций; если функция вычисляется быстро, то сотня лишних итераций не страшна.
Правда, в этом случае вам надо быть абсолютно уверенным, что при достаточно больших аргументах функция все-таки становится положительной,
а то вдруг она вообще всегда отрицательна...

\header{Целочисленный двоичный поиск}
Теперь перейдем к бинарному поиску, когда мы ищем некоторое целое число. Как ни странно, этот вариант оказывается сложнее вещественного поиска.

\lheader{Опять порог разрыва нити} Для начала вернемся к нашей задаче про прочность однородной невесомой нити. 
Но пусть теперь мы не можем подвесить к ней произвольный груз, а только груз массой в целое число грамм.

Прежде чем обсуждать, как решить эту задачу, обсудим, а \textit{что же, собственно, мы хотим получить}? 
Бессмысленно теперь спрашивать критическую массу, т.к. она, вообще говоря, может быть вещественной.
Но понятно, что у нас до некоторой массы ($m_*$) \textit{включительно} нить рваться не будет, а вот начиная с массы
$(m_*+1)$ \textit{включительно} и выше нить рваться будет. 
Поэтому нас будут интересовать именно две такие \textit{соседние} массы $l$ и $r$ (соседние в смысле, что $r=l+1$), что при массе $l$ нить еще не рвется,
а вот при массе $r$ нить уже рвется.

Заметьте, что постановка вопроса абсолютно симметрична относительно $l$ и $r$: нельзя сказать, что правильный ответ $l$, но не $r$; 
точно также нельзя сказать, что правильный ответ $r$, а не $l$. 
Мы можем ставить два симметричных вопроса: <<при какой максимальной массе нить еще не рвется>> (и ответ будет $l$)
или <<при какой минимальной массе нить уже рвется>> (и ответ будет $r$).
Они оба симметричны, поэтому бессмысленно говорить, что какой"=то из них более правильный или более логичный, поэтому
и бессмысленно говорить, что $l$ и $r$ более правильный или логичный ответ. 
Поэтому мы будем искать именно такую \textit{пару} чисел $l$ и $r$, а не какое"=то одно число.

Как это делать? Кажется достаточно просто:
\begin{codesampleo}\begin{verbatim}
l:=0;
r:=m_big;  // какая-нибудь масса M, при которой нить точно рвется
while ??? do begin    
    m:=(r+l) div 2;
    if (нить рвется от массы m) then
        r:=m
    else l:=m;
end;
\end{verbatim}
\end{codesampleo}
Но что написать в условие? 
Как мы уже обсудили выше, мы хотим найти два соседних числа $l$ и $r$. 
Поэтому цикл будем выполнять пока $r-l>1$ (или, что то же самое $r>l+1$), т.е. пока они еще не стали соседними.
В результате у нас всегда поддерживается состояние что от массы $l$ нить не рвется, а от массы $r$ нить рвется.

На каждом шагу расстояние между $l$ и $r$ уменьшается\dots Уменьшается ли?
Понятно, что оно не может уменьшаться до бесконечности: и $l$ и $r$ целые числа.
Поэтому ясно, что в некоторый момент окажется, что $m=l$ или $m=r$ и расстояние перестанет уменьшаться.
Но также несложно видеть, что \textbf{если $r-l>1$, то $l<m<r$}, причем неравенства строгие. 
Т.е. \textit{в этой реализации} бинарного поиска всегда внутри цикла будет $l<m<r$ со строгими неравенствами,
и поэтому расстояние будет уменьшаться.

Но это очень важный момент. Если бы мы в какой-нибудь другой задаче написали бы цикл с другим условием
\begin{codesampleo}\begin{verbatim}
// НЕПРАВИЛЬНЫЙ КОД!
...
while r>l do begin    
    m:=(r+l) div 2;
    if ... then
        r:=m
    else l:=m;
end;
\end{verbatim}
\end{codesampleo}
то программа очень легко могла бы зациклиться. Действительно, в какой"=то момент окажется $l=r-1$ (например, $l=4$, $r=5$).
Тогда получится $m=l$ (в примере $m=9\mbox{ div } 2=4=l$), выполнится вторая ветка if'а, и в результате ни $l$, ни $r$ не изменятся
(останется $l=4$, $r=5$). Цикл выполнится еще раз с тем же результатом, и так далее.

Это есть первая ловушка, в которую вы можете попасть, когда пишите деление пополам: когда $l$ и $r$ сходятся очень близко, 
в очередной момент может оказаться, что за одну итерацию ни $l$, ни $r$ не изменились, и программа зацикливается.
Всегда помните про это, если будете выдумывать свой способ написания бинарного поиска (хотя это стоит делать только в совсем особенных случаях);
в частности, никогда не пишите деление пополам с условием \verb`while r>l` (или \verb`while r<>l` или ему эквивалентным).

Итак, правильное решение задачи о целочисленном пределе прочности нити следующее:
\begin{codesampleo}\begin{verbatim}
l:=0;
r:=m_big;  // какая-нибудь масса M, при которой нить точно рвется
while r-l>1 do begin    
    m:=(r+l) div 2;
    if (нить рвется от массы m) then
        r:=m
    else l:=m;
end;
\end{verbatim}
\end{codesampleo}

Это действительно корректное решение, оно действительно работает. За какое время? 
Несложно видеть, что за $O(\log M)$ "--- каждая итерация уменьшает разницу $r-l$ примерно в два раза.

\lheader{Общий случай} Аналогично вещественному двоичному поиску, тут тоже можно сформулировать алгоритм в общем случае.
Итак, пусть у нас все целые числа разделены на две категории: <<хорошие>> и <<плохие>>, при этом все хорошие идут до всех плохих,
и мы знаем два числа: $l_0$ "--- хорошее, и $r_0$ "--- плохое. 

Нам надо найти границу между хорошими, т.е. такое хорошее число $l$ и такое плохое число $r$, что $r-l=1$. 
(Как и выше, постановка задачи симметрична относительно $l$ и $r$.)
Решение понятно:
\begin{codesampleo}\begin{verbatim}
l:=l0;
r:=r0;  
while r-l>1 do begin    
    m:=(r+l) div 2;
    if good(m) then
        l:=m
    else r:=m;
end;
\end{verbatim}
\end{codesampleo}

Это можно называть поиском скачка монотонной логической функции. 
В том смысле, что у вас есть функция \verb`good`, она логическая, 
т.е. возвращает значение логического (\verb`boolean`) типа,
и она монотонная, т.е. если $i<j$, то $good(i)\geq good(j)$ 
(мы считаем, что $\verb`true`>\verb`false`$; функция получается <<убывающей>>,
но могла бы быть и возрастающей, что соответствовало бы тому,
что сначала идут плохие числа, а потом хорошие, и потребовалось бы просто поменять местами $l$ и $r$
в ветках if'а). 

Обратите внимание на еще один важный момент. 
Приведенная выше программа никогда не будет вызывать функции \verb`good`
с аргументами $l_0$ или $r_0$; важны только значения для промежуточных аргументов.
Проще говоря, не важно, являются ли $l_0$ и $r_0$ хорошими или плохими числами
"--- главное, чтобы между ними все хорошие шли до всех плохих. 
Фактически, мы мысленно подразумеваем, что $l_0$ хорошее, а $r_0$ плохое, но
никогда это не проверяем.
(Аналогично замечанию про тангенс выше в вещественном поиске.)
Это нам будет важно в дальнейшем.

\lheadernd{Что же является ответом?}
В вещественном двоичном поиске $l$ и $r$ различались несущественно "--- разница между ними
была меньше $\eps$, и поэтому было все равно, какое из чисел выводить. 
Но в целочисленном двоичном поиске $l$ и $r$ различаются существенно, и поэтому
вопрос о том, что из них считать ответом, нетривиален.

Но, как я уже неоднократно писал выше, с точки зрения бинарного поиска $l$ и $r$ равнозначны.
Поэтому решение о том, что считать ответом, зависит от той задачи, в которой
вы решили применить бинарный поиск. 
Могут быть задачи, где ответом будет наибольшее хорошее число "--- тогда ответ будет $l$
(например, если бы в задаче про нитку стоял бы вопос <<какой максимальный целочисленный вес выдерживает нить?>>).
Могут быть задачи, где ответом будет наименьшее плохое число "--- тогда ответ будет $r$.
Могут быть задачи, где ответ вычисляется как"=нибудь еще более сложно, и т.д.

Главное "--- что бинарный поиск вам нашел границу <<хороших>> и <<плохих>> чисел,
а что делать с этим дальше "--- уже ваше дело, зависит от задачи.

\lheader{Поиск элемента в отсортированном массиве}
Очень важный частный случай бинарного поиска "--- это поиск заданного элемента в отсотированном массиве.
В простейшей постановке задача звучит так.
Вам дан массив $a$, и гарантируется, что он отсортирован по неубыванию: $a[i]\leq a[j]$ если $i<j$.
Кроме того, вам дано число $x$, и от вас требуется найти такой индекс $i$, что $a[i]=x$,
или сообщить, что такого индекса нет.

Нередко, когда говорят о бинпоиске, имеют в виду именно эту задачу, но написать программу
двоичного поиска элемента в отсортированном массиве, не учитывая то, что написано выше,
"--- очень сложно%
\footnote{Д. Кнут утверждает, что, хотя первый раз двоичный поиск был опубликован в 1946 году,
первая реализация двоичного поиска \textit{без ошибок} появилась только в 1962 году. 
Есть еще один известный эксперимент, что только 10\% программистов могут написать двоичный поиск без багов.
См. подробнее \texttt{http://habrahabr.ru/post/91605/} и указанные там ссылки.}%
.

Но с учетом того, что мы уже знаем, написать эту програму становится очень легко. 
Надо только определить, какие числа мы будем считать <<хорошими>>, а какие "--- <<плохими>>.
Давайте, например, определим так: <<хорошими>> мы будем считать такие числа $i$, что $a[i]<x$,
а <<плохими>> "--- такие, что $a[i]\geq x$. 
(Обратите внимание, что хорошими и плохими мы называем \textit{индексы} массива, а не сами значения массива.)
В результате у нас все хорошие значения будут идти до плохих значений, и можно применить деление пополам.

Заметим, что, в отличие от вещественного двоичного поиска, здесь довольно важно, к какому варианту 
отнести ситуацию точного равенства $a[i]=x$, т.к. такие элементы вполне могут существовать,
и, более того, их может быть несколько.
Пока поступим так, как написано выше: будем считать такие индексы плохими;
подробнее обсудим ниже.

Только чему взять равным $l_0$ и $r_0$?
Вспомним, что бинарному поиску не важно, хорошие или плохие числа $l_0$ и $r_0$ "---
важны только промежуточные числа. 
Поэтому "--- внимание! "--- можно взять $l_0=0$, а $r_0=N+1$, если элементы в массиве
у нас занумерованы от $1$ до $N$. 

Т.е. мы берем $l_0$ перед первым элементом массива, а $r_0$ "--- после последенего.
Можно мысленно считать, что перед первым элементом массива у нас идет бесконечно большое отрицательное число
(которое меньше всех других и гарантированно меньше $x$), а после последнего "---
бесконечно большое положительное число.
Мы все равно никогда не будем реально проверять, чему равно $a[l_0]$ или $a[r_0]$.

Итоговый код получается следующий:
\begin{codesampleo}\begin{verbatim}
l:=0;
r:=n+1;  
while r-l>1 do begin    
    m:=(r+l) div 2;
    if a[m]<x then
        l:=m
    else r:=m;
end;
\end{verbatim}
\end{codesampleo}

\lheadernd{А что является тут ответом?}
Напомним постановку задачи: надо найти такой индекс $i$, что $a[i]=x$, либо сообщить,
что такого нет. Как это сделать?

Вспомним определение хороших и плохих чисел: $a[l]<x$, а $a[r]\geq x$ всегда.
Поэтому в конце, когда $r=l+1$, это значит, что мы нашли два числа подряд такие,
что одно меньше $x$, а второе "--- больше или равно $x$.

Тогда понятно, что если $a[r]=x$, то ответ "--- $r$, иначе такого индекса нет.
Правда, есть сложность: может оказаться $r=r_0=N+1$ (если $x$ больше всех элементов массива, см. также ниже). 
Это надо не забыть и явно проверить, чтобы не получить выход за пределы массива.

\lheader{Левый и правый двоичные поиски}
Из написанного выше несложно видеть, что, если искомое число в массиве есть, то мы не просто его найдем,
но найдем \textit{самое левое} (т.е. с наименьшим индексом) его вхождение.

А есл мы хотим найти \textit{самое правое}? 
Это тоже довольно легко: просто надо $i$ считать хорошим числом, если $a[i]=x$, 
т.е. поменять строгое на нестрогое неравенство и наоборот в определении хороших и плохих чисел.
Индекс будем считать хорошим, если $a[i]\leq x$, и плохим наоборот. Получаем следующее решение:
\begin{codesampleo}\begin{verbatim}
l:=0;
r:=n+1;  
while r-l>1 do begin    
    m:=(r+l) div 2;
    if a[m]<=x then    // отличие только в этой строчке!
        l:=m
    else r:=m;
end;
\end{verbatim}
\end{codesampleo}
(Проверять теперь надо, конечно, $a[l]$: если он равен $x$, то искомый индекс "--- $l$, 
иначе число $x$ в массиве отсутствует.)

Эти два варианта двоичного поиска называются \textit{левым} и \textit{правым} двоичным поиском.

Давайте еще обсудим более подробно, что же именно происходит, если нужный элемент в массиве не найден.
Тогда мы находим два таких соседних индекса $l$ и $r$, что $a[l]<x$, а $a[r]>x$.
Это можно определить так: мы находим то место, куда надо было бы вставить значение $x$, 
если бы мы хотели вставить его в массив, сохранив отсортированность "--- а именно,
его надо вставить между элементами $l$ и $r$.

В частности, может оказаться, что $l=0$ и $r=1$ "--- это значит, что $x$ меньше всех элементов массива.
Может оказаться, что $l=n$, $r=n+1$ "--- т.е. $x$ больше всех элементов массива.
Но утверждение, что мы нашли место, куда надо было бы вставить $x$, верно во всех случаях, 
и это зачастую оказывается полезно.

В частности, обратите внимание, что, например, правый поиск работал бы, даже если бы мы взяли $l_0=1$, 
но тогда мы не смогли бы отличить ситуацию <<$x$ надо вставить перед первым элементом>> 
и <<$x$ надо вставить сразу после первого элемента>>.
Аналогично, левый поиск работал бы, если бы мы взяли $r_0=n$, но мы бы не отличили 
случай <<$x$ надо ставить после всех элементов>> и <<$x$ надо вставить перед последним>>.

Терминология поиска места, куда надо вставить $x$, также достаточно просто
работает и в случае, когда $x$ найдено.
Для левого поиска получается $l$ равно последней позиции перед первым вхождением $x$,
а $r$ "--- первому вхождению $x$. 
Таким образом, левый поиск показывает, куда надо было бы вставить число $x$,
чтобы сохранить упорядоченность, причем если такие элементы в массиве уже есть,
то надо вставить перед первым таким элементом.
Аналогично, правый поиск ищет, куда надо вставить число $x$, чтобы сохранить упорядоченность,
пичем если такие элементы в массиве уже есть, то он пытается вставить после последнего из них.

\lheader{Ошибки в целочисленном бинарном поиске}
Выше приведен очень простой и надежный код поиска элемента в отсортированном массиве.
В принципе, есть много разных других способов реализации, но многие из них сложнее
или менее надежные; не случайно эта задача считается весьма сложной.

Упомяну несколько вариантов кода, которые могут показаться разумными, но которые тем не менее 
имеют те или иные недостатки или вообще не работают.

Во"=первых, может появиться желание во внутреннем if'е разобрать случай точного попадания в $x$:
если $a[m]=x$, то прервать работу. Это имеет три недостатка. 
Во"=первых, теперь теряются преимущества левого и правого поисков; вы никогда не можете
быть уверены, какое вхождение вы найдете, если их несколько.
Во"=вторых, может возникнуть желание писать цикл с условием \verb`while l<>r` или даже
\verb`while l<=r` (<<пока еще остаются нерассмотренные элементы>>), 
но тогда есть, как указывалось выще, риск зацикливания.
В"=третьих, код становится в полтора раза сложнее из"=за лишнего условия.

Еще стандартный подход "--- взять изачально $l=1$, $r=n$. Это имеет два недостатка. 
Во"=первых, вы не сможете отделить случаи <<$x$ меньше всех элементов массива>> и 
<<$x$ надо вставить между первым и вторым элементами>>, 
и аналогично не сможете отличить случаи <<$x$ больше всех элементов массива>> и 
<<$x$ надо вставить между последние и предпоследним элементами>>.
Более того, если $x$ все"=таки нашелся, то он может быть как в элементе $l$,
так и в элементе $r$, поэтому после основного цикла поиска потребуется еще одна проверка.

Есть еще один вариант, который долгое время считался <<совсем правильным>>. 
Идея состоит в том, чтобы поддерживать $l$ и $r$ так, что искомое число $x$, 
если оно есть в массиве, лежит в \textit{полуинтервале} индексов $[l,r)$,
т.е. что искомый индекс $i$ удовлетворяет условию $l\leq i<r$.
(Аналогично можно требовать полуинтервал $(l,r]$).
Это довольно хороший подход, код получается в точности таким же, 
как указано выше, только с другой инициализацией $l$ "--- можно взять $l=1$.
Получается правый поиск (для $(l,r]$ "--- левый), и единственная проблема
"--- невозможно отличить случай <<$x$ меньше всех элементов массива>> и 
<<$x$ надо вставить между первым и вторым элементами>>
(для $(l,r]$ "--- два симметричных случая на другом конце массива).

\lheader{Деление пополам по ответу}
Деление пополам по ответу "--- это важный способ применения деления пополам.
Фактически, это применение приведенных выше кодов с функцией $f$, только 
в ситуации, когда значение функции $f$ вычисляется сложным образом.

Рассмотрим классический пример. 
Есть $N$ прямоугольных листов бумаги (<<дипломов>>) одинакого размера 
$w\times h$. Можно купить квадратную доску размера $L\times L$, 
повесить ее на стену так, чтобы одна сторона была горизонтальной,
а другая вертикальной, и на эту доску повесить эти дипломы. При этом
дипломы тоже надо повесить не поворачивая: сторона $w$ должна быть
горизонтальной, а сторона $h$ "--- вертикальной.
Какой минимальный размер доски ($L$) требуется, чтобы повесить все дипломы?

Понятно, что дипломы надо вешать на доску один вплотную к другому 
начиная с угла "--- так, что они будут образовывать решетку с шагом
по горизонтали $w$, а по вертикали "--- $h$.
Предположим, что мы выбрали некоторый размер доски $L$.
Сколько максимум дипломов можно на нее повесить?
Несложно видеть, что ответом будет $(L\mbox{ div }h)\cdot(L\mbox{ div }w)$.

Итак, мы научились решать задачу, в некотором смысле обратную даной:
по размеру доски мы научились определять количество дипломов.
При этом понятно, что чем больше будет размер доски, тем больше будет
дипломов, и наоборот. 

Поэтому мы можем применить бинарный поиск. 
А именно, мы знаем, что доска размера 0 нам точно не подходит.
Доска некоторого большого размера (например, $Nw+Nh$) нам точно подходит.
Объявим все размеры досок, которые нам подходят, <<хорошими>>,
а все размеры, которые нам не подходят "--- <<плохими>>.
Ясно, что все плохие числа идут до хороших.
Поэтому делением пополам мы можем найти границу "--- два соседних числа,
одно из которых плохое, а другое "--- хорошее.
Далее очевидно, что это хорошее число и будет ответом:
\begin{codesampleo}\begin{verbatim}
function good(x:integer):boolean;
var nn:integer;
begin
nn:=(x div w)*(x div h); // столько дипломов можно повесить на доску размера x
result:=nn>=n; // если это >= чем общее число дипломов, то да
end;

...

l:=l0;
r:=r0;  
while r-l>1 do begin    
    m:=(r+l) div 2;
    if good(m) then
        r:=m
    else l:=m;
end;
writeln(r);
\end{verbatim}
\end{codesampleo}

То есть мы просто задаем конкретную реализацию функции \verb`good`,
которая будет определять "--- может ли быть наше число ответом.

Это и называется делением пополам по ответу. 
Вы пишете функцию, которая проверяет, может ли быть некоторое число ответом.
И вы доказываете, что все ответы идут после всех <<не"=ответов>>.
Поэтому вы объявляете все ответы <<хорошими>>, <<не"=ответы>> "--- плохими,
и запускаете деление пополам для поиска границы.

(Вообще, мы фактически вернулись к тому же, с чего начинали: если вы вспомните
задачу о разрыве нитки, которую мы обсуждали вначале, то фактически там мы
и реализовывали деление пополам по ответу.)

%\inputanswers

\end{document}
